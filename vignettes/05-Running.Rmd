---
title: "OpenML"
author: "The OpenML R Team"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{OpenML}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r init, include=FALSE}
# library("knitr")
# opts_chunk$set(cache = TRUE)
library("OpenML")
setOMLConfig(apikey = "c1994bdb7ecb3c6f3c8f3b35f4b47f1f")
```

# Running {#running}
The modularized structure of OpenML allows to apply the implementation of an algorithm to a specific task and there exist multiple possibilities to do this.

## Run a task with a specified mlr learner
If one is working with [**mlr**](https://github.com/mlr-org/mlr), one can specify a `RLearner` object and use the function `runTaskMlr` to create the desired `"OMLMlrRun"` object.
The `task` is created the same way as in the previous sections:
```{r, warning = FALSE, message = FALSE}
task = getOMLTask(task.id = 59L)

library(mlr)
lrn = makeLearner("classif.rpart")
run.mlr = runTaskMlr(task, lrn)
run.mlr
```
Note that locally created runs don't have a run ID or flow ID yet. These are assigned by the OpenML server after uploading the run.

## Run a task without using mlr
If one is not using **mlr**, one will have to invest quite a bit more time and effort to get things done. So, unless there are good reasons to do otherwise, we strongly encourage to use **mlr**.

The following example shows how to create an OpenML flow description object manually.

The first step is to create a list of `OMLFlowParameter`, where each parameter of your implementation is stored. Let's assume we have written an algorithm that has two parameters called `a` (with default value: `500`) and `b` (with default value: `TRUE`).
```{r}
flow.par.a = makeOMLFlowParameter(
  name = "a",
  data.type = "numeric",
  default.value = "500",  # All defaults must be passed as strings.
  description = "An optional description of parameter a.")

flow.par.b = makeOMLFlowParameter(
  name = "b",
  data.type = "logical",
  default.value = "TRUE",
  description = "An optional description of parameter b.")

flow.pars = list(flow.par.a, flow.par.b)
```
Now we can create the whole description object.
When creating a new flow, one should try to find a good name for the algorithm, so the other users get an idea of what is actually happening.
```{r}
oml.flow = makeOMLFlow(
  name = "good_name",
  external.version = "1.0",
  description = "A proper description of your algorithm, changes, etc.",
  parameter = flow.pars)
```

Before one can apply the created flow to a task, one has to create a `OMLRun` object.
If one wants to change the parameter settings for the run, one can do this by a list that contains an `OMLRunParameter` objects for each parameter defined by the flow **whose setting varies from the default**.
The class `OMLRunParameter` has the following slots:

* name
* value
* component (optional and only needed if the parameter belongs to a (sub-)component of the implementation. Then, the name of this component must be handed over here.) (**??? Fixme: What is a (sub-)component? Any good example here???**)

Let's assume that we want to set the parameter `a` to a value of `300`.
Parameter `b`, on the other hand, remains in the default setting, so that we do not need to define a `OMLRunParameter` for it:
```{r}
run.par.a = makeOMLRunParameter(name = "a", value = "300")
run.pars = list(run.par.a)
```
Now one can create the `OMLRun` object using the `makeOMLRun` function.
If one wants to upload the run to OpenML it is necessary to create a `data.frame` for the `predictions` parameter before actually creating the run with `makeOMLRun`. Note that the `data.frame` for the `predictions` has to be in a **standardized form**.
The call `task$output$predictions` returns the expected column names and their types.
For supervised classification and regression tasks, these are:

```{r}
str(task$output$predictions$features)
```
The columns `repeat`, `fold` and `row_id` have to be zero-based, i.e., we start numbering with 0 and not with 1 as we would usually do in R. There is an example in the next subsection.

Additionally, in case of a classification task, one needs:

* confidence.*classname_1*
* confidence.*classname_2*
* etc

i.e., one column for each level of the target variable.


### Example: An excerpt of predictions (Iris data set, 2x10-fold CV).

Now, we first show, how one could create the predictions and then, how to perform an OpenML run with these predictions. In the given scenario, we used two repetitions (`repeat` can be either `0` or `1`) of a 10-fold cross-validation (`fold` can be in `0:9`). The data set has 150 observations, thus, the `row_id` can be in `0:149`.

(**??? Fixme: This is created WHILE or AFTER running the learner? I.e. `prediction` and `confidence.xyz` are the results of the learner? And how would one usually create all these objects? I.e. are the run parameters perhaps the result from cross-validation?**)

```{r, message=FALSE}
task = getOMLTask(task.id = 59L)
iris.data = task$input$data.set$data

set.seed(1907)  # set seed for reproducible results
preds = data.frame(rep(0:1, each = nrow(iris.data)),
  rep(0:9, each = nrow(iris.data)/10),
  sample(1:nrow(iris.data)) - 1)
names(preds) = c("repeat", "fold", "row.id")
head(preds)
```
(**??? Fixme: Why can't one specify `repeat = ...`**)

```
    repeat fold row_id      prediction confidence.Iris-setosa confidence.Iris-versicolor confidence.Iris-virginica
1        0    0    140  Iris-virginica                      0                          0                         1
...    ...  ...    ...             ...                    ...                        ...                       ...
51       0    3     37     Iris-setosa                      1                          0                         0
...    ...  ...    ...             ...                    ...                        ...                       ...
150      0    9     76  Iris-virginica                      0                          0                         1
151      1    0    110  Iris-virginica                      0                          0                         1
...    ...  ...    ...             ...                    ...                        ...                       ...
300      1    9     58 Iris-versicolor                      0                          1                         0
```

(**??? Fixme: Is it possible to NOT wrap the above code block but use scroll bars instead? This would strongly increase readability. Problem would be the PDF version, though.**)

Once such a data frame has been created, one can create an OpenML run by calling:

```{r eval = FALSE}
run = makeOMLRun(task.id = 59L, parameter.setting = run.pars, predictions = preds)
```
This run can now be uploaded to the [OpenML server](http://openml.org) as we will show in the next section.
