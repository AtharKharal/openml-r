.listOMLRunEvaluations = function(task.id = NULL, flow.id = NULL, run.id = NULL,
  uploader.id = NULL, tag = NULL, limit = NULL, offset = NULL, verbosity = NULL) {

  if (is.null(task.id) && is.null(flow.id) && is.null(run.id) && is.null(uploader.id) && is.null(tag))
    stop("Please hand over at least one of the following: task.id, flow.id, run.id, uploader.id, tag")

  api.call = generateAPICall(api.call = "json/evaluation/list", task.id = task.id, flow.id = flow.id,
    run.id = run.id, uploader.id = uploader.id, tag = tag, limit = limit, offset = offset)

 #  'data.frame': 807 obs. of  33 variables:
 # $ run.id                       : int  62 237 359 413 500 517 540 559 614 6079 ...
 # $ task.id                      : int  1 1 1 1 1 1 1 1 1 1 ...
 # $ setup.id                     : int  17 4 12 10 15 13 16 3 1 5 ...
 # $ flow.id                      : int  76 59 67 65 74 70 75 58 56 60 ...
 # $ area.under.roc.curve         : num  0.995 0.979 0.992 0.999 0.997 ...
 # $ area.under.roc.curve.array   : Factor w/ 322 levels "[0.4,0.493881,0.492649,?,0.482075,0.499068]",..: 150 28 247 177 83 245 54 127 2 144 ...
 # $ average.cost                 : int  0 0 0 0 0 0 0 0 0 0 ...
 # $ confusion.matrix             : Factor w/ 230 levels "[[0,0,7,0,1,0],[0,49,42,0,8,0],[0,2,682,0,0,0],[0,0,0,0,0,0],[0,0,0,0,67,0],[0,0,39,0,0,1]]",..: 74 51 226 205 151 174 2 223 4 95 ...
 # $ f.measure                    : num  0.984 0.983 0.963 0.991 0.989 ...
 # $ f.measure.array              : Factor w/ 232 levels "[0,0,0.864728,0,0,0]",..: 83 60 143 205 173 182 4 97 1 115 ...
 # $ kappa                        : num  0.961 0.961 0.907 0.978 0.972 ...
 # $ kb.relative.information.score: num  831 823 788 830 853 ...
 # $ mean.absolute.error          : num  0.00931 0.00799 0.01639 0.01113 0.00355 ...
 # $ mean.prior.absolute.error    : num  0.134 0.134 0.134 0.134 0.134 ...
 # $ number.of.instances          : int  898 898 898 898 898 898 898 898 898 898 ...
 # $ number.of.instances.array    : Factor w/ 1 level "[8,99,684,0,67,40]": 1 1 1 1 1 1 1 1 1 1 ...
 # $ precision                    : num  0.984 0.985 0.968 0.991 0.989 ...
 # $ precision.array              : Factor w/ 231 levels "[0,0,0.761693,0,0,0]",..: 66 116 75 163 183 91 3 53 1 144 ...
 # $ predictive.accuracy          : num  0.984 0.984 0.961 0.991 0.989 ...
 # $ prior.entropy                : num  1.21 1.21 1.21 1.21 1.21 ...
 # $ recall                       : num  0.984 0.984 0.961 0.991 0.989 ...
 # $ recall.array                 : Factor w/ 211 levels "[0,0,1,0,0,0]",..: 89 50 161 193 141 168 4 175 1 93 ...
 # $ relative.absolute.error      : num  0.0693 0.0595 0.122 0.0829 0.0265 ...
 # $ root.mean.prior.squared.error: num  0.258 0.258 0.258 0.258 0.258 ...
 # $ root.mean.squared.error      : num  0.0637 0.0705 0.0986 0.0589 0.057 ...
 # $ root.relative.squared.error  : num  0.247 0.273 0.382 0.228 0.221 ...
 # $ total.cost                   : int  0 0 0 0 0 0 0 0 0 0 ...
 # $ os.information               : Factor w/ 27 levels "[Apple Inc., 1.6.0_65, x86_64, Mac OS X, 10.10.5]",..: NA NA NA NA NA NA NA NA NA NA ...
 # $ scimark.benchmark            : num  NA NA NA NA NA NA NA NA NA NA ...
 # $ scimark.benchmark.array      : Factor w/ 123 levels "[1062.2659455227413, 1422.1069969560601, 811.9030863840538, 1690.1611873706404, 3825.802659788186]",..: NA NA NA NA NA NA NA NA NA NA ...
 # $ usercpu.time.millis          : num  NA NA NA NA NA NA NA NA NA NA ...
 # $ usercpu.time.millis.testing  : num  NA NA NA NA NA NA NA NA NA NA ...
 # $ usercpu.time.millis.training : num  NA NA NA NA NA NA NA NA NA NA ...

  content = doAPICall(api.call, file = NULL, method = "GET", verbosity = verbosity)

  evals = fromJSON(txt = content)$evaluations$evaluation

  # convert long format to wide format
  evals = reshape(evals,
    timevar = "function",
    idvar = c("run_id", "task_id", "setup_id", "flow_id"),
    direction = "wide")

  # drop "all NA" columns
  evals = evals[, vlapply(evals, function(x) !all(is.na(x)))]

  # unfortunately column names are f***ed up now. Some tedious work is neccessary
  # to achive our naming conventions
  colnames(evals) = gsub("value[.]", "", colnames(evals))
  arr.ind = grepl("array_data[.]", colnames(evals))
  colnames(evals)[arr.ind] = paste0(gsub("array_data[.]", "", colnames(evals)[arr.ind]), ".array")

  # convert types (by default all is character)
  evals = as.data.frame(lapply(evals, type.convert, numerals = "no.loss", as.is = TRUE))

  # finally convert _ to . in col names
  names(evals) = convertNamesOMLToR(names(evals))

  return(evals)
}

#' @title List run results of a task.
#'
#' @description
#' Retrieves all run results for task(s) (\code{task.id}), flow(s) (\code{flow.id})
#' run(s) (\code{run.id}) or uploaders(s) (\code{uploader.id} and returns a \code{data.frame}.
#' Each row contains, among others, the run id \dQuote{rid}. Alternatively the
#' function can be passed a single \code{tag} to list only runs with the corresponding
#' tag associated.
#'
#' @template note_memoise
#'
#' @inheritParams listOMLRuns
#' @return [\code{data.frame}].
#' @family list
#' @export
#' @example inst/examples/listOMLRunEvaluations.R
listOMLRunEvaluations = memoise(.listOMLRunEvaluations)
